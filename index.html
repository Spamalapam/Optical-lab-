<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Optical Lab - Organic Physics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Roboto+Mono:wght@400&display=swap');

        /* BASE */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; padding: 0; width: 100vw; height: 100vh; 
            overflow: hidden; background: #050505; color: #e0e0e0; 
            font-family: 'Inter', sans-serif; display: flex; flex-direction: column;
        }

        /* LAYOUT */
        #canvas-wrapper {
            position: relative; width: 100%; flex: 1;
            background: linear-gradient(to bottom, #111, #080808);
            touch-action: none; overflow: hidden;
        }

        #controls-wrapper {
            width: 100%; height: 50vh; background: #111;
            border-top: 1px solid #333; display: flex; flex-direction: column; z-index: 10;
        }

        /* HEADER */
        header {
            position: absolute; top: 0; left: 0; width: 100%; padding: 15px 20px;
            pointer-events: none; z-index: 5;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: start;
        }
        h1 { margin: 0; font-weight: 300; font-size: 1.1rem; letter-spacing: 1px; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,1); }
        .subtitle { font-size: 0.75rem; color: #4facfe; font-weight: 600; text-transform: uppercase; }

        /* PATIENT VIEW (Retina) */
        #retina-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 150px; height: 150px;
            background: #000; border: 2px solid #444;
            border-radius: 12px; overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            z-index: 6; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #retina-container.expanded {
            width: 300px; height: 300px; bottom: 50%; left: 50%;
            transform: translate(-50%, 50%);
            border-color: #4facfe;
            box-shadow: 0 0 60px rgba(0,0,0,0.9);
            z-index: 20;
        }
        #retina-label {
            position: absolute; top: 0; left: 0; width: 100%;
            background: rgba(0,0,0,0.7); color: #fff; font-size: 0.65rem; 
            padding: 4px 0; text-align: center; backdrop-filter: blur(4px);
            text-transform: uppercase; letter-spacing: 1px;
        }
        #scene-toggles {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: flex; background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
        }
        .scene-btn {
            flex: 1; border: none; background: transparent; color: #666;
            padding: 8px 0; font-size: 12px; cursor: pointer;
            border-top: 2px solid transparent; transition: all 0.2s;
        }
        .scene-btn.active { color: #4facfe; border-top-color: #4facfe; background: rgba(79, 172, 254, 0.1); }

        #retina-canvas { width: 100%; height: 100%; background: #000; }
        
        /* BRAIN MODE INDICATOR */
        #brain-indicator {
            position: absolute; top: 10px; right: 10px; 
            background: rgba(255, 50, 50, 0.8); color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 0.6rem;
            text-transform: uppercase; letter-spacing: 1px;
            display: none; pointer-events: none;
        }

        /* CONTROLS */
        #controls-scroll { flex: 1; overflow-y: auto; padding: 20px; -webkit-overflow-scrolling: touch; }
        .control-section { margin-bottom: 25px; }
        .control-header { 
            font-size: 0.75rem; color: #666; text-transform: uppercase; letter-spacing: 1px; 
            margin-bottom: 12px; border-bottom: 1px solid #222; padding-bottom: 5px;
        }
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .control-row label { color: #ccc; font-size: 0.9rem; }
        .val { color: #4facfe; font-weight: 600; font-family: 'Roboto Mono', monospace; font-size: 0.9rem; }

        /* INPUTS */
        input[type=range] {
            width: 100%; -webkit-appearance: none; background: transparent; height: 36px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: #333; border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
            background: #fff; margin-top: -8px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            border: 2px solid #111;
        }
        input[type=range]:active::-webkit-slider-thumb { background: #4facfe; transform: scale(1.2); }

        .btn-large {
            width: 100%; padding: 14px; background: #222; color: #fff;
            border: 1px solid #444; border-radius: 8px; font-weight: 600;
            display: flex; align-items: center; justify-content: center; gap: 10px;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        .btn-large.active { background: #4facfe; color: #000; border-color: #4facfe; box-shadow: 0 0 15px rgba(79, 172, 254, 0.3); }
        
        .btn-brain {
            background: #2a1a1a; border-color: #552222; color: #ff9999;
        }
        .btn-brain.active {
            background: #ff4444; color: white; border-color: #ff0000; box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
        }

        /* DESKTOP TWEAKS */
        @media (min-width: 768px) {
            body { flex-direction: row; }
            #canvas-wrapper { height: 100vh; }
            #controls-wrapper { width: 360px; height: 100vh; border-left: 1px solid #333; border-top: none; }
            #retina-container { width: 200px; height: 200px; bottom: 30px; left: 30px; }
        }
    </style>
</head>
<body>

<div id="canvas-wrapper">
    <header>
        <div>
            <h1>OPTICAL LAB</h1>
            <div class="subtitle">Clinical View</div>
        </div>
    </header>
    
    <div id="retina-container">
        <div id="retina-label">Patient View</div>
        <div id="brain-indicator">BRAIN FILTER ACTIVE</div>
        <div style="width: 100%; height: calc(100% - 30px); position: relative;" onclick="document.getElementById('retina-container').classList.toggle('expanded')">
            <canvas id="retina-canvas" width="300" height="300"></canvas>
        </div>
        
        <div id="scene-toggles">
            <button class="scene-btn active" onclick="sim.setScene('landscape', this)">Landscape</button>
            <button class="scene-btn" onclick="sim.setScene('reading', this)">Reading</button>
            <button class="scene-btn" onclick="sim.setScene('night', this)">Night</button>
        </div>
    </div>
</div>

<div id="controls-wrapper">
    <div id="controls-scroll">
        
        <div class="control-section">
            <div class="control-header">Patient Rx</div>
            <div class="control-row"><label>Sphere</label><span id="val-rx-sph" class="val">-3.00 D</span></div>
            <input type="range" id="inp-rx-sph" min="-10" max="10" step="0.25" value="-3.00" oninput="sim.updateRx()">

            <div class="control-row" style="margin-top:15px;"><label>Cylinder</label><span id="val-rx-cyl" class="val">-0.00 D</span></div>
            <input type="range" id="inp-rx-cyl" min="-6" max="0" step="0.25" value="0.00" oninput="sim.updateRx()">

            <div class="control-row" style="margin-top:15px;"><label>Axis</label><span id="val-rx-axis" class="val">180Â°</span></div>
            <input type="range" id="inp-rx-axis" min="0" max="180" step="1" value="180" oninput="sim.updateRx()">
        </div>

        <div class="control-section">
            <div class="control-header">Visual Processing</div>
            <button class="btn-large btn-brain" id="btn-brain-toggle" onclick="sim.toggleBrainMode()">
                <span id="btn-brain-icon">ðŸ§ </span> <span id="btn-brain-text">Activate Neural Compensation</span>
            </button>
            <p style="font-size: 0.7rem; color: #666; margin-top: 5px; line-height: 1.4;">
                Simulates how the brain "sharpens" blurry input by hallucinating details. Sharpness increases, but accuracy decreases.
            </p>
        </div>

        <div class="control-section">
            <div class="control-header">Correction</div>
            <button class="btn-large" id="btn-lens-toggle" onclick="sim.toggleLens()">
                <span id="btn-icon">ðŸ‘“</span> <span id="btn-text">Add Corrective Lens</span>
            </button>

            <div id="lens-controls" style="opacity: 0.4; pointer-events: none; margin-top: 20px; transition: opacity 0.3s;">
                <div class="control-row"><label>Lens Sphere</label><span id="val-lens-sph" class="val">0.00 D</span></div>
                <input type="range" id="inp-lens-sph" min="-12" max="12" step="0.25" value="0" oninput="sim.manualLens()">
                
                <div class="control-row" style="margin-top:10px;"><label>Lens Cyl</label><span id="val-lens-cyl" class="val">0.00 D</span></div>
                <input type="range" id="inp-lens-cyl" min="-8" max="0" step="0.25" value="0" oninput="sim.manualLens()">
                
                <div class="control-row" style="margin-top:10px;"><label>Lens Axis</label><span id="val-lens-axis" class="val">180Â°</span></div>
                <input type="range" id="inp-lens-axis" min="0" max="180" step="1" value="180" oninput="sim.manualLens()">
            </div>
        </div>

    </div>
</div>

<script>
const sim = {
    scene: null, camera: null, renderer: null, controls: null,
    K: 1 / 1440.0, BASE_POWER: 60.0,

    state: {
        rx: { sph: -3.00, cyl: 0.00, axis: 180 },
        eye: { axialLength: 24.0 },
        lens: { active: false, sph: 0, cyl: 0, axis: 180 },
        sceneMode: 'landscape',
        brainMode: false
    },

    objects: { eyeGroup: null, eyeContainer: null, eyeMesh: null, lensMesh: null, rays: [] },
    mats: { glass: null, sclera: null, ray: null },
    
    // Hallucination Dictionaries
    hallucinations: {
        "VISION": "VERSION",
        "TEST": "TEXT",
        "Hold": "Hand",
        "card": "cart",
        "insufficient": "isegnificant",
        "Myopes": "Myspecs",
        "read": "road",
        "easily": "vastly"
    },

    init: function() {
        this.scene = new THREE.Scene();
        const container = document.getElementById('canvas-wrapper');
        const w = container.clientWidth;
        const h = container.clientHeight;
        
        this.camera = new THREE.PerspectiveCamera(40, w/h, 0.1, 100);
        this.camera.position.set(-22, 12, 32);
        this.camera.lookAt(0, 0, 8);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(w, h);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(this.renderer.domElement);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.enablePan = false;

        this.scene.add(new THREE.AmbientLight(0x333333, 3));
        const spot = new THREE.SpotLight(0xffffff, 5);
        spot.position.set(10, 20, 10);
        this.scene.add(spot);
        const rim = new THREE.PointLight(0x4facfe, 2);
        rim.position.set(-10, 0, -5);
        this.scene.add(rim);

        // GLASS LENS
        this.mats.glass = new THREE.MeshPhysicalMaterial({
            color: 0x88ccff,          
            metalness: 0.05,
            roughness: 0.1,           
            transmission: 0.25,      
            thickness: 2.0,
            transparent: true,
            opacity: 0.7,             
            ior: 1.5, 
            side: THREE.DoubleSide, 
            clearcoat: 1.0,
            clearcoatRoughness: 0.1
        });

        this.mats.sclera = new THREE.MeshPhongMaterial({
            color: 0xeeeeee, opacity: 0.15, transparent: true, wireframe: true
        });
        this.mats.ray = new THREE.LineBasicMaterial({
            color: 0x4facfe, transparent: true, opacity: 0.8, linewidth: 2
        });

        this.buildScene();
        this.updateRx();
        this.animate();

        window.addEventListener('resize', () => {
            const c = document.getElementById('canvas-wrapper');
            this.camera.aspect = c.clientWidth / c.clientHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(c.clientWidth, c.clientHeight);
        });
    },

    buildScene: function() {
        this.objects.eyeGroup = new THREE.Group();
        this.scene.add(this.objects.eyeGroup);

        this.objects.eyeContainer = new THREE.Group();
        this.objects.eyeGroup.add(this.objects.eyeContainer);

        const eyeGeo = new THREE.SphereGeometry(12, 32, 24);
        eyeGeo.rotateX(Math.PI/2);
        this.objects.eyeMesh = new THREE.Mesh(eyeGeo, this.mats.sclera);
        this.objects.eyeContainer.add(this.objects.eyeMesh);

        const retGeo = new THREE.PlaneGeometry(8, 8);
        const retMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, opacity: 0.2, transparent: true });
        this.objects.retinaPlane = new THREE.Mesh(retGeo, retMat);
        this.objects.eyeGroup.add(this.objects.retinaPlane);

        const lensGeo = new THREE.CylinderGeometry(4, 4, 0.2, 128, 16, false);
        this.objects.lensMesh = new THREE.Mesh(lensGeo, this.mats.glass);
        this.objects.lensMesh.position.z = -8; 
        this.objects.lensMesh.rotation.x = Math.PI/2; 
        this.objects.lensMesh.visible = false;
        this.objects.lensMesh.userData.baseGeometry = lensGeo.clone();
        
        this.scene.add(this.objects.lensMesh);

        for(let i=0; i<40; i++) {
            const angle = (i / 40) * Math.PI * 2;
            const r = 3.5 * (i%2===0 ? 1.0 : 0.6); 
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(12), 3));
            const line = new THREE.Line(geo, this.mats.ray);
            line.userData = { ox: x, oy: y };
            this.scene.add(line);
            this.objects.rays.push(line);
        }
    },

    setScene: function(mode, btn) {
        this.state.sceneMode = mode;
        document.querySelectorAll('.scene-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.calculateRays(); 
    },

    toggleBrainMode: function() {
        this.state.brainMode = !this.state.brainMode;
        const btn = document.getElementById('btn-brain-toggle');
        const indicator = document.getElementById('brain-indicator');
        
        if (this.state.brainMode) {
            btn.classList.add('active');
            indicator.style.display = 'block';
            document.getElementById('btn-brain-text').innerText = "Deactivate Neural Compensation";
        } else {
            btn.classList.remove('active');
            indicator.style.display = 'none';
            document.getElementById('btn-brain-text').innerText = "Activate Neural Compensation";
        }
        this.calculateRays();
    },

    hallucinateText: function(text) {
        if (!this.state.brainMode) return text;
        return text.split(' ').map(word => {
            const cleanWord = word.replace(/[.,]/g, '');
            const punct = word.replace(cleanWord, '');
            if (this.hallucinations[cleanWord]) {
                return this.hallucinations[cleanWord] + punct;
            }
            return word;
        }).join(' ');
    },

    updateRx: function() {
        this.state.rx.sph = parseFloat(document.getElementById('inp-rx-sph').value);
        this.state.rx.cyl = parseFloat(document.getElementById('inp-rx-cyl').value);
        this.state.rx.axis = parseInt(document.getElementById('inp-rx-axis').value);

        document.getElementById('val-rx-sph').innerText = (this.state.rx.sph > 0 ? "+" : "") + this.state.rx.sph.toFixed(2) + " D";
        document.getElementById('val-rx-cyl').innerText = this.state.rx.cyl.toFixed(2) + " D";
        document.getElementById('val-rx-axis').innerText = this.state.rx.axis + "Â°";

        const effectiveP = this.BASE_POWER + this.state.rx.sph;
        this.state.eye.axialLength = 1.0 / (effectiveP * this.K);

        const scaleZ = this.state.eye.axialLength / 24.0;
        const axisRad = this.state.rx.axis * (Math.PI/180);
        this.objects.eyeContainer.rotation.z = axisRad;
        
        const squeeze = Math.abs(this.state.rx.cyl) * 0.05; 
        if (this.state.rx.cyl < 0) {
            this.objects.eyeMesh.scale.set(1.0 + squeeze, 1.0 - squeeze, scaleZ);
        } else {
            this.objects.eyeMesh.scale.set(1.0, 1.0, scaleZ);
        }
        
        this.objects.eyeMesh.position.z = 12 * scaleZ;
        this.objects.retinaPlane.position.z = this.state.eye.axialLength;

        this.calculateRays();
    },

    manualLens: function() {
        this.state.lens.sph = parseFloat(document.getElementById('inp-lens-sph').value);
        this.state.lens.cyl = parseFloat(document.getElementById('inp-lens-cyl').value);
        this.state.lens.axis = parseInt(document.getElementById('inp-lens-axis').value);
        this.updateLensUI();
        this.calculateRays();
    },

    toggleLens: function() {
        this.state.lens.active = !this.state.lens.active;
        const btn = document.getElementById('btn-lens-toggle');
        const ctrls = document.getElementById('lens-controls');

        if (this.state.lens.active) {
            this.state.lens.sph = this.state.rx.sph;
            this.state.lens.cyl = this.state.rx.cyl;
            this.state.lens.axis = this.state.rx.axis;
            document.getElementById('inp-lens-sph').value = this.state.lens.sph;
            document.getElementById('inp-lens-cyl').value = this.state.lens.cyl;
            document.getElementById('inp-lens-axis').value = this.state.lens.axis;
            btn.classList.add('active');
            document.getElementById('btn-text').innerText = "Remove Corrective Lens";
            ctrls.style.opacity = 1; ctrls.style.pointerEvents = 'auto';
            this.objects.lensMesh.visible = true;
        } else {
            btn.classList.remove('active');
            document.getElementById('btn-text').innerText = "Add Corrective Lens";
            ctrls.style.opacity = 0.4; ctrls.style.pointerEvents = 'none';
            this.objects.lensMesh.visible = false;
        }
        this.updateLensUI();
        this.calculateRays();
    },

    updateLensUI: function() {
        document.getElementById('val-lens-sph').innerText = (this.state.lens.sph>0?"+":"")+this.state.lens.sph.toFixed(2)+" D";
        document.getElementById('val-lens-cyl').innerText = this.state.lens.cyl.toFixed(2)+" D";
        document.getElementById('val-lens-axis').innerText = this.state.lens.axis+"Â°";
        if(this.state.lens.active) this.updateLensGeometry();
    },

    updateLensGeometry: function() {
        const mesh = this.objects.lensMesh;
        const pos = mesh.geometry.attributes.position;
        const basePos = mesh.userData.baseGeometry.attributes.position;
        const count = pos.count;
        
        const s = this.state.lens.sph;
        const c = this.state.lens.cyl;
        const aRad = this.state.lens.axis * (Math.PI / 180);
        const baseThickness = 0.15; 
        const powerFactor = 0.025; 
        
        mesh.rotation.z = 0; 

        for (let i = 0; i < count; i++) {
            const x = basePos.getX(i);
            const y = basePos.getY(i);
            const z = basePos.getZ(i);
            const r = Math.sqrt(x*x + z*z);
            const theta = Math.atan2(x, z); 
            const axisDiff = theta - aRad;
            const cylFactor = Math.cos(axisDiff); 
            const localPower = s + c * (cylFactor * cylFactor);
            const sag = (r * r) * (-localPower) * powerFactor;
            const originalYSign = Math.sign(y);
            let halfThick = baseThickness + sag;
            if (halfThick < 0.02) halfThick = 0.02;

            pos.setY(i, originalYSign * halfThick);
            pos.setX(i, x);
            pos.setZ(i, z);
        }

        pos.needsUpdate = true;
        mesh.geometry.computeVertexNormals();
    },

    calculateRays: function() {
        const Z_SRC = -20; const Z_LENS = -8; const Z_CORNEA = 0; const Z_RETINA = this.state.eye.axialLength;
        const hits = []; const K = this.K; const BaseP = this.BASE_POWER; 

        this.objects.rays.forEach(ray => {
            const ox = ray.userData.ox; const oy = ray.userData.oy;
            const pos = ray.geometry.attributes.position.array;
            pos[0]=ox; pos[1]=oy; pos[2]=Z_SRC; pos[3]=ox; pos[4]=oy; pos[5]=Z_LENS;

            let slopeX = 0, slopeY = 0;
            if (this.state.lens.active) {
                slopeX -= ox * this.state.lens.sph * K;
                slopeY -= oy * this.state.lens.sph * K;
                const ang = Math.atan2(oy, ox);
                const axisRad = this.state.lens.axis * (Math.PI/180);
                const cylPower = this.state.lens.cyl * Math.pow(Math.sin(ang - axisRad), 2);
                slopeX -= ox * cylPower * K; slopeY -= oy * cylPower * K;
            }

            const d1 = Z_CORNEA - Z_LENS;
            const cx = ox + slopeX * d1; const cy = oy + slopeY * d1;
            pos[6]=cx; pos[7]=cy; pos[8]=Z_CORNEA;

            const angC = Math.atan2(cy, cx);
            const patAxisRad = this.state.rx.axis * (Math.PI/180);
            const cylError = -this.state.rx.cyl * Math.pow(Math.sin(angC - patAxisRad), 2);
            const sphError = -this.state.rx.sph;
            const totalEyeD = BaseP + sphError + cylError;

            slopeX -= cx * totalEyeD * K; slopeY -= cy * totalEyeD * K;
            const d2 = Z_RETINA - Z_CORNEA;
            const rx = cx + slopeX * d2; const ry = cy + slopeY * d2;
            pos[9]=rx; pos[10]=ry; pos[11]=Z_RETINA;

            ray.geometry.attributes.position.needsUpdate = true;
            hits.push({x:rx, y:ry});
        });
        this.drawPatientView(hits);
    },

    drawPatientView: function(hits) {
        const cvs = document.getElementById('retina-canvas');
        const ctx = cvs.getContext('2d');
        const w = cvs.width, h = cvs.height;

        ctx.filter = 'none';
        ctx.globalAlpha = 1.0;
        
        if (this.state.sceneMode === 'night') { ctx.fillStyle = "#050505"; } else { ctx.fillStyle = "#fff"; }
        ctx.fillRect(0,0,w,h);

        const rxS = this.state.rx.sph;
        let effectiveRxS = rxS;
        if (this.state.lens.active) effectiveRxS -= this.state.lens.sph;
        
        let effectiveCyl = this.state.rx.cyl;
        if (this.state.lens.active) effectiveCyl -= this.state.lens.cyl;

        if (this.state.sceneMode === 'landscape') {
            this.drawLandscapeScene(ctx, w, h, hits, effectiveRxS, effectiveCyl);
        } else if (this.state.sceneMode === 'reading') {
            this.drawReadingScene(ctx, w, h, hits, effectiveRxS, effectiveCyl);
        } else if (this.state.sceneMode === 'night') {
            this.drawNightScene(ctx, w, h, hits, effectiveRxS, effectiveCyl);
        }
    },

    getBlurAmount: function(rxSph, objectVergenceD) {
        const accom = 4.00; 
        const minP = -rxSph; 
        const maxP = -rxSph + accom;
        
        let blur = 0;
        if (objectVergenceD < minP) {
            blur = Math.abs(minP - objectVergenceD);
        } else if (objectVergenceD > maxP) {
            blur = Math.abs(objectVergenceD - maxP);
        } else {
            blur = 0; 
        }

        if (this.state.brainMode) {
            const errorMag = Math.abs(rxSph) + Math.abs(this.state.rx.cyl);
            const compFactor = Math.max(0, 1.0 - (errorMag / 6.0));
            blur = blur * (1.0 - (compFactor * 0.85));
        }
        // SCALED BACK BLUR GROWTH (User Request 2)
        // Reduced from 12 to 10.5 to delay the onset of severe blur
        return Math.min(blur * 10.5, 60); 
    },

    // --- LANDSCAPE SCENE ---
    drawLandscapeScene: function(ctx, w, h, hits, sph, cyl) {
        let jitter = 0;
        if (Math.abs(cyl) > 0.25) jitter = Math.abs(cyl) * 20;

        if (this.state.brainMode) {
            ctx.filter = 'contrast(1.4) saturate(1.2)';
        }

        // 1. DRAW BASE LAYER (OPAQUE)
        // Mountains moved here to fix transparency (User Request 1)
        const blurInf = this.getBlurAmount(sph, 0);
        const blurGround = this.getBlurAmount(sph, 0.2);
        
        // Base Sky
        ctx.save();
        ctx.filter = `blur(${blurInf}px)`;
        const skyGrad = ctx.createLinearGradient(0, 0, 0, h);
        skyGrad.addColorStop(0, "#4facfe");
        skyGrad.addColorStop(0.5, "#fff");
        ctx.fillStyle = skyGrad;
        ctx.fillRect(-w, -h, w*3, h*3);
        ctx.restore();

        // Mountains (Now Opaque Base)
        ctx.save();
        ctx.filter = `blur(${blurInf}px)`;
        ctx.fillStyle = "#708090"; 
        const horizonY = h * 0.55; 
        const centerX = w * 0.5;
        ctx.beginPath();
        ctx.moveTo(-w, horizonY);
        ctx.lineTo(centerX - 200, horizonY - 100);
        ctx.lineTo(centerX, horizonY - 50);
        ctx.lineTo(centerX + 200, horizonY - 150);
        ctx.lineTo(w*2, horizonY);
        ctx.fill();
        ctx.restore();

        // Base Ground
        ctx.save();
        ctx.filter = `blur(${blurGround}px)`;
        const groundGrad = ctx.createLinearGradient(0, horizonY, 0, h);
        groundGrad.addColorStop(0, "#556B2F"); groundGrad.addColorStop(1, "#228B22"); 
        ctx.fillStyle = groundGrad;
        ctx.fillRect(-w, horizonY, w*3, h*3);
        ctx.restore();

        // 2. DRAW JITTERED OBJECTS
        if (jitter > 0) {
            const passes = 8;
            ctx.globalAlpha = 0.2;
            let avgX = 0, avgY = 0;
            hits.forEach(p => { avgX += p.x; avgY += p.y; });
            avgX /= hits.length; avgY /= hits.length;
            const step = Math.ceil(hits.length/passes);
            
            for(let i=0; i<hits.length; i+=step) {
                const p = hits[i];
                const dx = (p.x - avgX) * (jitter * 0.8);
                const dy = -(p.y - avgY) * (jitter * 0.8);
                this.renderLandscapeObjects(ctx, w, h, dx, dy, sph, cyl);
            }
            ctx.globalAlpha = 1.0;
        } else {
            this.renderLandscapeObjects(ctx, w, h, 0, 0, sph, cyl);
        }
        ctx.filter = 'none';
    },

    renderLandscapeObjects: function(ctx, w, h, dx, dy, sph, cyl) {
        const horizonY = h * 0.55 + dy; 
        const centerX = w * 0.5 + dx;
        const blurInf = this.getBlurAmount(sph, 0);

        // Sun
        ctx.save();
        ctx.filter = this.state.brainMode ? `contrast(1.2) blur(${blurInf}px)` : `blur(${blurInf}px)`;
        ctx.fillStyle = "#FFD700"; 
        const sunX = w*0.8 + dx*0.5;
        const sunY = h*0.2 + dy*0.5;
        ctx.beginPath(); ctx.arc(sunX, sunY, 40, 0, Math.PI*2); ctx.fill();
        if (Math.abs(cyl) > 0.5) {
            ctx.fillStyle = "rgba(255, 255, 200, 0.4)";
            for(let k=0; k<12; k++) {
                const ang = Math.random() * Math.PI * 2;
                const dist = 40 + Math.random() * Math.abs(cyl) * 30;
                ctx.beginPath(); ctx.arc(sunX + Math.cos(ang)*dist, sunY + Math.sin(ang)*dist, 4 + Math.random()*4, 0, Math.PI*2); ctx.fill();
            }
        }
        ctx.restore();

        // Grid Lines
        ctx.save();
        ctx.filter = `blur(${this.getBlurAmount(sph, 0.2)}px)`;
        ctx.beginPath(); ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 2;
        for(let i=-20; i<=20; i++) {
            const xOffset = i * 100 + dx; 
            ctx.moveTo(w/2 + xOffset*0.1, horizonY); ctx.lineTo(w/2 + xOffset*3, h + 500); 
        }
        ctx.stroke();
        ctx.restore();

        // Hallucination Threshold Logic (User Request 3)
        // Switch only happens if error is high (>= 4.0 D)
        const totalError = Math.abs(sph) + Math.abs(cyl);
        const allowHallucination = this.state.brainMode && (totalError >= 4.0);

        // Mid Object (Log vs Bench)
        const blurLog = this.getBlurAmount(sph, 0.25);
        ctx.save();
        ctx.filter = this.state.brainMode ? `contrast(1.3) blur(${blurLog}px)` : `blur(${blurLog}px)`;
        ctx.fillStyle = "#8B4513";
        
        if (allowHallucination) {
            // Bench
            ctx.fillRect(centerX + 120, horizonY + 30, 80, 10);
            ctx.fillRect(centerX + 120, horizonY + 40, 8, 15);
            ctx.fillRect(centerX + 190, horizonY + 40, 8, 15);
            ctx.fillStyle = "#5d2e0b";
            ctx.fillRect(centerX + 120, horizonY + 15, 80, 8);
        } else {
            // Log
            ctx.beginPath();
            ctx.ellipse(centerX + 160, horizonY + 45, 40, 10, Math.PI/12, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();

        // Foreground Object (Person vs Rock)
        const blurFar = this.getBlurAmount(sph, 0.17);
        ctx.save();
        ctx.filter = this.state.brainMode ? `contrast(1.3) blur(${blurFar}px)` : `blur(${blurFar}px)`;
        
        if (allowHallucination) {
            // Rock
            ctx.fillStyle = "#777";
            ctx.beginPath();
            ctx.ellipse(centerX - 100, horizonY + 10, 25, 15, 0, 0, Math.PI*2);
            ctx.fill();
        } else {
            // Person
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.ellipse(centerX - 100, horizonY + 5, 10, 20, 0, 0, Math.PI*2);
            ctx.arc(centerX - 100, horizonY - 15, 8, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();

        // Foreground Tree (0.5 D)
        const blurTree = this.getBlurAmount(sph, 0.5);
        ctx.save();
        ctx.filter = this.state.brainMode ? `contrast(1.3) blur(${blurTree}px)` : `blur(${blurTree}px)`;
        ctx.fillStyle = "#8B4513"; ctx.fillRect(centerX + 80, horizonY - 20, 15, 40); 
        ctx.fillStyle = "#2E8B57"; ctx.beginPath(); ctx.arc(centerX + 87, horizonY - 35, 25, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Foreground Bush (Using ~3.0D effective distance logic for -3.00 myope visibility)
        // User wants visibility at -3.00. -3.00 Myope has FP at 33cm.
        // We set vergence to 3.0D.
        const blurBush = this.getBlurAmount(sph, 3.0); 
        ctx.save();
        ctx.filter = this.state.brainMode ? `contrast(1.3) blur(${blurBush}px)` : `blur(${blurBush}px)`;
        ctx.fillStyle = "#006400"; 
        ctx.beginPath();
        ctx.arc(centerX - 40, h + dy, 60, 0, Math.PI*2);
        ctx.arc(centerX + 40, h + dy + 20, 70, 0, Math.PI*2);
        ctx.arc(centerX, h + dy - 20, 50, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    },

    // --- READING SCENE ---
    drawReadingScene: function(ctx, w, h, hits, sph, cyl) {
        const sphEquiv = sph + (cyl / 2);
        const baseBlur = this.getBlurAmount(sphEquiv, 2.50) * 0.5;

        // HELPER: Draw Text
        const drawText = (offsetX, offsetY, opacity, localBlur) => {
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.globalAlpha = opacity;
            
            let filterStr = "";
            if (localBlur > 0) filterStr += `blur(${localBlur}px) `;
            if (this.state.brainMode) filterStr += `contrast(2.5) `; // Higher contrast for text (Request 4)
            ctx.filter = filterStr;

            ctx.fillStyle = "#000"; ctx.font = "bold 18px sans-serif";
            ctx.textAlign = "left";
            
            // Hallucination Step: Replace full words (User Request 4)
            const title = this.hallucinateText("NEAR VISION TEST");
            ctx.fillText(title, 20, 30);
            
            ctx.font = "14px serif";
            const text = "Hold this card at 40cm. If text is blurry, accommodation is insufficient. Myopes read easily.";
            const words = text.split(' ');
            let x=20, y=60;
            words.forEach(wd => {
                const finalWd = this.hallucinateText(wd);
                ctx.fillText(finalWd, x, y);
                x += ctx.measureText(finalWd).width + 5;
                if(x > w-20) { x=20 + offsetX; y+=24; }
            });
            ctx.font = "10px sans-serif";
            ctx.fillText("J1  J2  J3  J4", 20, y+30);
            ctx.restore();
        };

        // Draw background
        ctx.filter = 'none';
        ctx.fillStyle = "#fdfbf7"; ctx.fillRect(0,0,w,h); 

        // Main Text
        drawText(0, 0, 1.0, baseBlur);

        // Astigmatism Shadow
        if (Math.abs(cyl) > 0.25) {
            const axisRad = this.state.rx.axis * (Math.PI/180);
            const displacement = Math.abs(cyl) * 2.0; 
            const dx = Math.cos(axisRad) * displacement;
            const dy = Math.sin(axisRad) * displacement;

            const steps = 5;
            for (let i = 1; i <= steps; i++) {
                 const percent = i / steps;
                 const op = 0.3 * (1 - percent); 
                 const ox = dx * i;
                 const oy = dy * i;
                 const shadowBlur = baseBlur + (i * 1);
                 drawText(ox, oy, op, shadowBlur);
            }
        }
        
        ctx.globalAlpha = 1.0;
        ctx.filter = 'none';
    },

    // --- NIGHT SCENE (ROAD) ---
    drawNightScene: function(ctx, w, h, hits, sph, cyl) {
        ctx.fillStyle = "#050505"; ctx.fillRect(0,0,w,h);
        
        const horizonY = h * 0.45;
        const blurInf = this.getBlurAmount(sph, 0);

        // 1. Draw Road (Base)
        ctx.save();
        ctx.filter = `blur(${this.getBlurAmount(sph, 0.1)}px)`;
        ctx.fillStyle = "#1a1a1a";
        ctx.beginPath();
        ctx.moveTo(w*0.4, horizonY);
        ctx.lineTo(w*0.6, horizonY);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.fill();
        
        // Lane Lines
        ctx.strokeStyle = "#e0c000"; ctx.lineWidth = 2;
        ctx.setLineDash([20, 30]);
        ctx.beginPath();
        ctx.moveTo(w*0.5, horizonY);
        ctx.lineTo(w*0.5, h);
        ctx.stroke();
        ctx.restore();

        // 2. Lights Helper
        const drawLight = (x, y, color, radius, intensity, vergence) => {
            const lightBlur = this.getBlurAmount(sph, vergence);
            const size = radius + lightBlur * 0.5;
            
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            
            // Bloom
            let filterStr = `blur(${Math.max(2, lightBlur)}px)`;
            if (this.state.brainMode) filterStr += ` brightness(1.3)`;
            ctx.filter = filterStr;
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.arc(x, y, size, 0, Math.PI*2); ctx.fill();
            
            // Starburst (Astig)
            if (Math.abs(cyl) > 0.25) {
                ctx.filter = 'none'; // Clear blur for crisp streaks inside the bloom? No, streaks blur too.
                // Actually streaks should be relatively sharp but faded
                ctx.translate(x, y);
                let axisRad = (this.state.rx.axis) * (Math.PI/180);
                ctx.rotate(axisRad);
                
                const length = Math.abs(cyl) * 40 + size*2;
                const thickness = Math.max(1, 4 - Math.abs(cyl)*0.5);
                const streakGrad = ctx.createLinearGradient(-length, 0, length, 0);
                streakGrad.addColorStop(0, "rgba(0,0,0,0)");
                streakGrad.addColorStop(0.5, color);
                streakGrad.addColorStop(1, "rgba(0,0,0,0)");
                
                ctx.fillStyle = streakGrad;
                ctx.fillRect(-length, -thickness/2, length*2, thickness);
            }
            ctx.restore();
        };

        // 3. Draw Lights
        // Street Lamp (Overhead, distant)
        drawLight(w*0.75, h*0.3, "#aff", 8, 1.0, 0);

        // Oncoming Car (Headlights, distant)
        drawLight(w*0.42, horizonY + 20, "#fffaaa", 5, 0.8, 0.05);
        drawLight(w*0.46, horizonY + 20, "#fffaaa", 5, 0.8, 0.05);

        // Car in front (Taillights, mid-distance)
        drawLight(w*0.55, h*0.7, "#ff0000", 6, 0.6, 0.2);
        drawLight(w*0.65, h*0.7, "#ff0000", 6, 0.6, 0.2);
        
        ctx.globalCompositeOperation = 'source-over';
        ctx.filter = 'none';
    },

    animate: function() {
        requestAnimationFrame(() => this.animate());
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
};

window.onload = function() { sim.init(); };
</script>
</body>
</html>


